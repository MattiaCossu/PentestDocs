# File System
Windows support 5 type of file system, the mains are _FAT32_ and _NTFS_.

_FAT32_ -> Grant compatibility whit some kind of device, and cross compatibility whit OS.
Use 32 BIT for contiguous blocks.
The cons are limiting, for example the max disk size supported are 4 GB.
Do not integrate security mechanism for encryption or compression the data.
For that for permit encryption we have to use third party software. 

_NTFS_ -> New Technology File System is reliable and can restore file system consistency in case of system failure.
Out of the box provides set of granular permission.
Support Large Partitions, and it has built-in journaling, which means that changes to files ( add, edit, delete ) are recorded.
We have a few cons like poor compatibility whit mobile device and old device  

##### NTFS Permission 
NTFS have granular permission like:
- _Full Control_ -> Allows reading, writing , changing, deleting of files/folder.
- _Modify_ -> Allows reading, writing, and deleting of files/folders.
- _List Folder Contents_ -> Allows for viewing and listing folders and subfolders as well as executing files. Folders only inherit this permission.
- _Read and Execute_ -> Allows for viewing and listing folders and subfolders as well as executing files. Folders only inherit this permission.
- _Write_ -> Allows for adding files to folders and subfolders and writing to a file.
- _Read_ -> Allows for viewing and listing of folders and subfolders and viewing a file's contents.
- _Traverse Folder_ -> This allows or denies the ability to move through folders to reach other files or folders.

##### Integrity Control Access Control List (icacls)
#icacls is powerful utility for view and manage NTFS permission.
```cmd
icacls                                 # in folder context
icacls c:\<PATH>                       # out of folder 
```

The resource access level is listed after each user in the output. The possible inheritance settings are:
- `(CI)`: container inherit -> only subfolders of main folder (only folder)
- `(OI)`: object inherit -> only file in a directory no subfolder (only file)
- `(IO)`: inherit only -> only in child item and not in main folder 
- `(NP)`: do not propagate inherit -> inherit by a child ones time and stop inherit
- `(I)`: permission inherited from parent container -> permission inherit by father

Basic access permissions are as follows:
- `F` : full access
- `D` :  delete access
- `N` :  no access
- `M` :  modify access
- `RX` :  read and execute access
- `R` :  read-only access
- `W` :  write-only access

# Services 
Services in windows are manged by system called `Service Control Manager` (SCM), accessible via gui by _services.msc_, MMC add on component.

Via cli we can use _sc.exe_ by PowerShell cmdlet `Get-Service`.
```powershell
Get-Service | ? {$_.Status -eq "Running"} | select -First 2 |fl
```

A service can appear:
- _Running_
- _Stopped_
- _Paused_

A service can be launch:
- Automatic at system boot
- Manually
- Automatic at boot but with delay

We have three type of service:
- `Local Service`
- `Network Service`
- `System Service`

#### Debug a process
[Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) is a part of the Sysinternals tool suite. This tool can show which handles and DLL processes are loaded when a program runs.

#### Interact with a services
We can use `sc` for interact with local and network services.

_Gain Information_
```cmd
sc qc <SERVICE NAME>                                    # local
sc //hostname or ip of box query ServiceName            # network
```

_Stop and Start_
```cmd
sc stop <SERVICE NAME>
sc start <SERVICE NAME>
```

_Configure Services_
In this example we modify the bin path for wuaserv services.
```cmd
sc config wuauserv binPath=C:\Winbows\Perfectlylegitprogram.exe
```

_View Services Permission_
```cmd
sc sdshow <SERVICE NAME>   
```

This command display a _SDDL_ (`Security Descriptor Definition Language`).
It's a [security descriptor](https://docs.microsoft.com/en-us/windows/win32/secauthz/security-descriptors) for any [securable object](https://docs.microsoft.com/en-us/windows/win32/secauthz/securable-objects) in Windows Context.

````
D:(A;;CCLCSWRPLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)
````

The Security Descriptor contain the object's owner and primary group containing a: 
- `Discretionary Access Control List` (`DACL`) -> controlling access to an object.
- `System Access Control List` (`SACL`). -> used to account for and log access attempts

_Table of Content_
`D: (A;;CCLCSWRPLORC;;;AU)`

1. D: - the proceeding characters are DACL permissions
2. AU: - defines the security principal Authenticated Users
3. A;; - access is allowed
4. CC - SERVICE_QUERY_CONFIG is the full name, and it is a query to the service control manager (SCM) for the service configuration
5. LC - SERVICE_QUERY_STATUS is the full name, and it is a query to the service control manager (SCM) for the current status of the service
6. SW - SERVICE_ENUMERATE_DEPENDENTS is the full name, and it will enumerate a list of dependent services
7. RP - SERVICE_START is the full name, and it will start the service
8. LO - SERVICE_INTERROGATE is the full name, and it will query the service for its current status
9. RC - READ_CONTROL is the full name, and it will query the security descriptor of the service

We can use `Get-ACL` in powershell for view some human readable information.
We have to specify a path for a service in registry.
```powershell
Get-ACL -Path HKLM:\System\CurrentControlSet\Services\wuauserv | Format-List
```

# Sessions 
We have two type of session in Windows:
- _Interactive_ -> Interactive or local logon sessions, are create simple when a user log in a system with your credentials. we can require by runas a secondary logon sessions.
- _Non-Interactive_ -> Is represent by special windows account as they do not require login credential. There are 3 types of non-interactive accounts: the Local System Account, Local Service Account, and the Network Service Account. Non-interactive accounts are generally used by the Windows operating system to automatically start services and applications without requiring user interaction.

|Account|Description|
|---|---|
|Local System Account|Also known as the `NT AUTHORITY\SYSTEM` account, this is the most powerful account in Windows systems. It is used for a variety of OS-related tasks, such as starting Windows services. This account is more powerful than accounts in the local administrators group.|
|Local Service Account|Known as the `NT AUTHORITY\LocalService` account, this is a less privileged version of the SYSTEM account and has similar privileges to a local user account. It is granted limited functionality and can start some services.|
|Network Service Account|This is known as the `NT AUTHORITY\NetworkService` account and is similar to a standard domain user account. It has similar privileges to the Local Service Account on the local machine. It can establish authenticated sessions for certain network services.|
# Powershell
Build on top of the `.NET`, which is used for building and running applications on Windows.
PowerShell utilizes [cmdlets](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7), which are small single-function tools built into the shell.
Cmdlet are in the form of Verb-Noun. for example `Get-ChildItem`.

##### Aliases
Many cmdlet also have a aliases.
`Set-Location` -> Aliases -> _cd_ or _sl_
`Get-ChildItem` -> Aliases -> _ls_ or _cgi_

_Get all system Aliases_
```powershell
get-alias
```

_Create New Alias_
```powershell
New-Alias -Name "Show-Files" Get-ChildItem
```
##### Get Help
_Display simple help_
```powershell
help
Get-Help Get-AppPackage
Get-AppPackage /?
```
##### Run Scripts
```powershell
.\PowerView.ps1;Get-LocalGroup | fl
```

We can import a script such as a module whit:
```powershell
Import-Module .\PowerView.ps1
```

We can then either start a command and cycle through the options or type `Get-Module` to list all loaded modules and their associated commands.
```powershell
Get-Module | select Name,ExportedCommands | fl
```

##### Execution Policy
Sometimes we will find that we are unable to run scripts on a system. This is due to a security feature called the `execution policy`, which attempts to prevent the execution of malicious scripts. The possible policies are:

|**Policy**|**Description**|
|---|---|
|`AllSigned`|All scripts can run, but a trusted publisher must sign scripts and configuration files. This includes both remote and local scripts. We receive a prompt before running scripts signed by publishers that we have not yet listed as either trusted or untrusted.|
|`Bypass`|No scripts or configuration files are blocked, and the user receives no warnings or prompts.|
|`Default`|This sets the default execution policy, `Restricted` for Windows desktop machines and `RemoteSigned` for Windows servers.|
|`RemoteSigned`|Scripts can run but requires a digital signature on scripts that are downloaded from the internet. Digital signatures are not required for scripts that are written locally.|
|`Restricted`|This allows individual commands but does not allow scripts to be run. All script file types, including configuration files (`.ps1xml`), module script files (`.psm1`), and PowerShell profiles (`.ps1`) are blocked.|
|`Undefined`|No execution policy is set for the current scope. If the execution policy for ALL scopes is set to undefined, then the default execution policy of `Restricted` will be used.|
|`Unrestricted`|This is the default execution policy for non-Windows computers, and it cannot be changed. This policy allows for unsigned scripts to be run but warns the user before running scripts that are not from the local intranet zone.|

Below is an example of the current execution policy for all scopes.
```powershell
Get-ExecutionPolicy -List

        Scope ExecutionPolicy
        ----- ---------------
MachinePolicy       Undefined
   UserPolicy       Undefined
      Process       Undefined
  CurrentUser       Undefined
 LocalMachine    RemoteSigned
```

If we have a permission for modify the current policy sessions we can perform:
```powershell
Set-ExecutionPolicy Bypass -Scope Process
```

_Results_
```powershell
Get-ExecutionPolicy -List

        Scope ExecutionPolicy
        ----- ---------------
MachinePolicy       Undefined
   UserPolicy       Undefined
      Process          Bypass
  CurrentUser       Undefined
 LocalMachine    RemoteSigned
```
# WMI
#wmi 
_WHOAMI_ is a subsystem of powershell for monitoring a system.
The goal of WMI is to consolidate device and application management across corporate networks.

It is made up of the following components:
- _WMI Services_ -> The Windows Management Instrumentation process, which runs automatically at boot and acts as an intermediary between WMI providers, the WMI repository, and managing applications.
- _Managed objects_ -> Any logical or physical components that can be managed by WMI.
- _WMI Providers_ -> 	Objects that monitor events/data related to a specific object.
- _Classes_ -> These are used by the WMI providers to pass data to the WMI service.
- _Methods_ -> These are attached to classes and allow actions to be performed. For example, methods can be used to start/stop processes on remote machines.
- _WMI repository_ -> A database that stores all static data related to WMI.
- _CIM Object Manager_ -> The system that requests data from WMI providers and returns it to the application requesting it.
- _WMI API_ -> Enables applications to access the WMI infrastructure.
- _WMI Consumer_ -> Sends queries to objects via the CIM Object Manager.

Some of the uses for WMI are:
- Status information for local/remote systems
- Configuring security settings on remote machines/applications
- Setting and changing user and group permissions
- Setting/modifying system properties
- Code execution
- Scheduling processes
- Setting up logging

_USES_
```cmd
wmic /?                                           # get help
wmic os list brief                                # informetion on os
```

We can use PowerShell with `Get-WmiObject` [module](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod?view=powershell-5.1). This module is used to get instances of WMI classes or information about available classes.
```powershell
Get-WmiObject -Class Win32_OperatingSystem | select SystemDirectory,BuildNumber,SerialNumber,Version | ft
```

We can also use the `Invoke-WmiMethod` [module](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod?view=powershell-5.1), which is used to call the methods of WMI objects.
# Windows Security
## Security Identifier (SID)
#SID 
Each of the security principals on the system has a unique _security identifier_ generated automatically by the system.   
SIDs are strings values with different lengths, which are stored in the security database.
These SIDs are added to the user's access token to identify all actions that the user is authorized to take.

A SID consists of the Identifier Authority and the Relative ID (RID). In an Active Directory (AD) domain environment, the SID also includes the domain SID.

example SID 
```text
S-1-5-21-674899381-4069889467-2080702030-1002
```

_SID Structure_
```text
(SID)-(revision level)-(identifier-authority)-(subauthority1)-(subauthority2)-(etc)
```

|**Number**|**Meaning**|**Description**|
|---|---|---|
|S|SID|Identifies the string as a SID.|
|1|Revision Level|To date, this has never changed and has always been `1`.|
|5|Identifier-authority|A 48-bit string that identifies the authority (the computer or network) that created the SID.|
|21|Subauthority1|This is a variable number that identifies the user's relation or group described by the SID to the authority that created it. It tells us in what order this authority created the user's account.|
|674899381-4069889467-2080702030|Subauthority2|Tells us which computer (or domain) created the number|
|1002|Subauthority3|The RID that distinguishes one account from another. Tells us whether this user is a normal user, a guest, an administrator, or part of some other group|
## Security Accounts Manager (SAM) and Access Control Entries (ACE)
#SAM #ACE #ACL

*SAM* is a system which grants rights to a networks who asking to execute specific process.

The access rights themselves are managed by Access Control Entries ( #ACE) in Access Control Lists ( #ACL). The ACLs contain ACEs that define which users, groups, or processes have access to a file or to execute a process, for example.

The permissions to access a securable object are given by the security descriptor, classified into two types of ACLs: the `Discretionary Access Control List (DACL)` or `System Access Control List (SACL)`. Every thread and process started or initiated by a user goes through an authorization process. An integral part of this process is _access tokens_, validated by the _Local Security Authority_ ( #LSA). In addition to the SID, these access tokens contain other security-relevant information.

---
## User Account Controll
[User Account Control (UAC)](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) is a feature that enables a consent prompt for elevated activities. Applications have different `integrity` levels, and a program with a high level can perform tasks that could potentially compromise the system. When UAC is enabled, applications and tasks always run under the security context of a non-administrator account unless an administrator explicitly authorizes these applications/tasks to have administrator-level access to the system to run. It is a convenience feature that protects administrators from unintended changes but is not considered a security boundary.

When UAC is in place, a user can log into their system with their standard user account. When processes are launched using a standard user token, they can perform tasks using the rights granted to a standard user. Some applications require additional permissions to run, and UAC can provide additional access rights to the token for them to run correctly.

This [page](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) discusses how UAC works in great depth and includes the logon process, user experience, and UAC architecture. Administrators can use security policies to configure how UAC works specific to their organization at the local level (using secpol.msc), or configured and pushed out via Group Policy Objects (GPO) in an Active Directory domain environment. The various settings are discussed in detail [here](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-security-policy-settings). There are 10 Group Policy settings that can be set for UAC. The following table provides additional detail:

|Group Policy Setting|Registry Key|Default Setting|
|---|---|---|
|[User Account Control: Admin Approval Mode for the built-in Administrator account](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-admin-approval-mode-for-the-built-in-administrator-account)|FilterAdministratorToken|Disabled|
|[User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-allow-uiaccess-applications-to-prompt-for-elevation-without-using-the-secure-desktop)|EnableUIADesktopToggle|Disabled|
|[User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-behavior-of-the-elevation-prompt-for-administrators-in-admin-approval-mode)|ConsentPromptBehaviorAdmin|Prompt for consent for non-Windows binaries|
|[User Account Control: Behavior of the elevation prompt for standard users](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-behavior-of-the-elevation-prompt-for-standard-users)|ConsentPromptBehaviorUser|Prompt for credentials on the secure desktop|
|[User Account Control: Detect application installations and prompt for elevation](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-detect-application-installations-and-prompt-for-elevation)|EnableInstallerDetection|Enabled (default for home) Disabled (default for enterprise)|
|[User Account Control: Only elevate executables that are signed and validated](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-only-elevate-executables-that-are-signed-and-validated)|ValidateAdminCodeSignatures|Disabled|
|[User Account Control: Only elevate UIAccess applications that are installed in secure locations](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-only-elevate-uiaccess-applications-that-are-installed-in-secure-locations)|EnableSecureUIAPaths|Enabled|
|[User Account Control: Run all administrators in Admin Approval Mode](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-run-all-administrators-in-admin-approval-mode)|EnableLUA|Enabled|
|[User Account Control: Switch to the secure desktop when prompting for elevation](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-switch-to-the-secure-desktop-when-prompting-for-elevation)|PromptOnSecureDesktop|Enabled|
|[User Account Control: Virtualize file and registry write failures to per-user locations](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-virtualize-file-and-registry-write-failures-to-per-user-locations)|EnableVirtualization|Enabled|
[Source](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings)

The following diagram, adapted from the source [here](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works), illustrates how UAC works.
![[UAC.png]]

---

## Registry
#REGISTRY

The [Registry](https://en.wikipedia.org/wiki/Windows_Registry) is a hierarchical database in Windows critical for the operating system.
It stores low-level settings for the System and applications that choose to use it.

it's divided into:
- computer-specific data
- user-specific data

We can consulting it whit `regedit` GUI utility.
![[registry 1.png]]

The tree-structure consists of main folders (_root keys_) in which subfolders (_subkeys_) with their entries/files (values) are located. There are 11 different types of values that can be entered in a subkey.

|**Value**|**Type**|
|---|---|
|REG_BINARY|Binary data in any form.|
|REG_DWORD|A 32-bit number.|
|REG_DWORD_LITTLE_ENDIAN|A 32-bit number in little-endian format. Windows is designed to run on little-endian computer architectures. Therefore, this value is defined as REG_DWORD in the Windows header files.|
|REG_DWORD_BIG_ENDIAN|A 32-bit number in big-endian format. Some UNIX systems support big-endian architectures.|
|REG_EXPAND_SZ|A null-terminated string that contains unexpanded references to environment variables (for example, "%PATH%"). It will be a Unicode or ANSI string depending on whether you use the Unicode or ANSI functions. To expand the environment variable references, use the [**ExpandEnvironmentStrings**](https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-expandenvironmentstringsa) function.|
|REG_LINK|A null-terminated Unicode string containing the target path of a symbolic link created by calling the [**RegCreateKeyEx**](https://docs.microsoft.com/en-us/windows/desktop/api/Winreg/nf-winreg-regcreatekeyexa) function with REG_OPTION_CREATE_LINK.|
|REG_MULTI_SZ|A sequence of null-terminated strings, terminated by an empty string (\0). The following is an example: _String1_\0_String2_\0_String3_\0_LastString_\0\0 The first \0 terminates the first string, the second to the last \0 terminates the last string, and the final \0 terminates the sequence. Note that the final terminator must be factored into the length of the string.|
|REG_NONE|No defined value type.|
|REG_QWORD|A 64-bit number.|
|REG_QWORD_LITTLE_ENDIAN|A 64-bit number in little-endian format. Windows is designed to run on little-endian computer architectures. Therefore, this value is defined as REG_QWORD in the Windows header files.|
|REG_SZ|A null-terminated string. This will be either a Unicode or an ANSI string, depending on whether you use the Unicode or ANSI functions.|
Source: [https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry-value-types](https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry-value-types)

Each folder under `Computer` is a key. The root keys all start with `HKEY`. A key such as `HKEY-LOCAL-MACHINE` is abbreviated to `HKLM` for example.

Always for example this keys (HKLM) contains six subkeys:
- `SAM`,
- `SECURITY`, 
- `SYSTEM`, 
- `SOFTWARE`, 
- `HARDWARE`, 
- `BCD`
![[Registry 2.png]]

_In the system where are stored?_
The entire system registry is stored in several files on the operating system. You can find these under `C:\Windows\System32\Config\`.

The user-specific registry hive (HKCU) is stored in the user folder (i.e., `C:\Users\<USERNAME>\Ntuser.dat`).

### Run end RunOnce Keys
Is a keys that contain history of user usage of a system

```text
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce
```

Here is an example of the `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run` key while logged in to a system.
```bash
reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
```

Here is an example of the `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run` showing applications running under the current user while logged in to a system.
```cmd
reg query HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
```

---
## Application Whitelisting
An application whitelist is a list of approved software allowed to be present on a system.

Blacklisting, in contrast, specifies a list of harmful or disallowed software/applications to block, and all others are allowed to run/be installed. Whitelisting is based on a "zero trust" principle in which all software/applications are deemed "bad" except for those specifically allowed.

---
## AppLocker
#applocker 
[AppLocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/applocker-overview) is Microsoft's application whitelisting solution and was first introduced in Windows 7. AppLocker gives system administrators control over which applications and files users can run. It gives granular control over executables, scripts, Windows installer files, DLLs, packaged apps, and packed app installers.

---
## Local Group Policy
Group Policy allows administrators to set, configure, and adjust a variety of settings. In a domain environment, group policies are pushed down from a Domain Controller onto all domain-joined machines that Group Policy objects (GPOs) are linked to. These settings can also be defined on individual machines using Local Group Policy.

We can open the Local Group Policy Editor by opening the Start menu and typing `gpedit.msc`. The editor is split into two categories under Local Computer Policy - `Computer Configuration` and `User Configuration`.
## Windows Authentication Process
In Windows the Authentication process can work by some components.
![[Windows Auth Process.png]]
In Summary.
- #LSA is the local security authority that implements security policies.
- #LSASS is the service that performs the functionality of LSA, managing authentication and security processes.
- #SAM is the database that stores user account credentials and other security information.

_LSA (Local Security Authority)_:
#LSA
- **What it is**: LSA is a subcomponent of the Windows operating system responsible for enforcing system security policies.
- **Main functions**: Manages user authentications, verifies access tokens, maintains user privilege information, and implements security policies.
- **Interactions**: Interfaces with other security components such as LSASS and SAM to perform its functions.

_LSASS (Local Security Authority Subsystem Service)_:
#LSASS
- **What it is**: LSASS is a system service running on Windows that implements Local Security Authority functionality.
- **Main functions**: Manages local and remote authentications, manages user login processes, creates access tokens, and enforces security policies.
- **Importance**: It is a critical component of system security. If LSASS is terminated or malfunctions, the system may crash and the computer may need to be restarted.

_SAM (Security Account Manager)_:
#SAM 
 - **What it is**: SAM is a system database that stores local user account information, including passwords.
- **Main functions**: It stores user credentials and security account information such as SID (Security Identifier).
- **Use**: During the authentication process, LSASS queries SAM to verify user credentials. SAM works closely with LSA and LSASS to provide secure authentication.
![[Sam Process.png]]